use std::{env, fs, fs::File, io::Write, path::Path, process::Command};

use proc_macro2::{Ident, Span, TokenStream};
use quote::{quote, ToTokens};
use serde::Deserialize;

fn main() -> Result<(), String> {
    generate_code_for_examples();

    parse_benches();

    Ok(())
}

fn generate_code_for_examples() {
    let out_dir = std::env::var("OUT_DIR").unwrap();

    let dest_path = Path::new(&out_dir).join("examples_generated.rs");

    let b;
    let l;
    let b_small;
    let k;
    let kappa;
    let wit_len;
    let x_len;

    let ring = std::env::var("RING").unwrap_or("Goldilocks".to_string());
    if ring != "StarkPrime" {
        b = std::env::var("PARAM_B").unwrap_or("1 << 15".to_string());
        l = std::env::var("PARAM_L").unwrap_or("5".to_string());
        b_small = std::env::var("PARAM_B_SMALL").unwrap_or("2".to_string());
        k = std::env::var("PARAM_K").unwrap_or("15".to_string());
        kappa = std::env::var("PARAM_KAPPA").unwrap_or("4".to_string());
        wit_len = std::env::var("PARAM_WIT_LEN").unwrap_or("4".to_string());
        x_len = std::env::var("PARAM_X_LEN").unwrap_or("1".to_string());
    } else {
        b = std::env::var("PARAM_B").unwrap_or("1073741824u128".to_string());
        l = std::env::var("PARAM_L").unwrap_or("9".to_string());
        b_small = std::env::var("PARAM_B_SMALL").unwrap_or("2".to_string());
        k = std::env::var("PARAM_K").unwrap_or("30".to_string());
        kappa = std::env::var("PARAM_KAPPA").unwrap_or("4".to_string());
        wit_len = std::env::var("PARAM_WIT_LEN").unwrap_or("4".to_string());
        x_len = std::env::var("PARAM_X_LEN").unwrap_or("1".to_string());
    }

    let mut generated_code = format!(
        r#"
        // This file was automatically generated by build.rs script.
        // It can be used in examples with include! macro:
        //     include!(concat!(env!("OUT_DIR"), "/examples_generated.rs"));
        //
        // Check examples/README.md file how to use environment variables to modify the file

        #[allow(dead_code)]
        use latticefold::decomposition_parameters::DecompositionParams;

        #[derive(Clone)]
        pub struct GoldilocksExampleDP {{}}

        impl DecompositionParams for GoldilocksExampleDP {{
            const B: u128 = {b}; // Default: 1 << 15
            const L: usize = {l}; // Default: 5
            const B_SMALL: usize = {b_small}; // Default = 2
            const K: usize = {k}; // Default = 15
        }}

        #[derive(Clone)]
        pub struct StarkPrimeExampleDP {{}}

        impl DecompositionParams for StarkPrimeExampleDP {{
            const B: u128 = {b}; // Default: 1073741824u128
            const L: usize = {l}; // Default: 9
            const B_SMALL: usize = {b_small}; // Default = 2
            const K: usize = {k}; // Default = 30
        }}

        #[derive(Clone)]
        pub struct BabyBearExampleDP {{}}

        impl DecompositionParams for BabyBearExampleDP {{
            const B: u128 = {b}; // Default: 1 << 15
            const L: usize = {l}; // Default: 5
            const B_SMALL: usize = {b_small}; // Default = 2
            const K: usize = {k}; // Default = 15
        }}

        #[derive(Clone)]
        pub struct FrogExampleDP {{}}

        impl DecompositionParams for FrogExampleDP {{
            const B: u128 = {b}; // Default: 1 << 15
            const L: usize = {l}; // Default: 5
            const B_SMALL: usize = {b_small}; // Default = 2
            const K: usize = {k}; // Default = 15
        }}

        const X_LEN: usize = {x_len}; // Default = 1
        const KAPPA: usize = {kappa}; // Default = 4
        const WIT_LEN: usize = {wit_len}; // Default = 4

        const N_GOLDILOCKS: usize = WIT_LEN * GoldilocksExampleDP::L;
        const N_BABYBEAR: usize = WIT_LEN * BabyBearExampleDP::L;
        const N_FROG: usize = WIT_LEN * FrogExampleDP::L;
        const N_STARK: usize = WIT_LEN * StarkPrimeExampleDP::L;
        "#,
    );

    match ring.as_str() {
        "Goldilocks" => generated_code.push_str(
            r#"
            const N: usize = N_GOLDILOCKS;
            type DP = GoldilocksExampleDP;
            type RqNTT = cyclotomic_rings::rings::GoldilocksRingNTT;
            type CS = cyclotomic_rings::rings::GoldilocksChallengeSet;
            "#,
        ),
        "BabyBear" => generated_code.push_str(
            r#"
            const N: usize = N_BABYBEAR;
            type DP = BabyBearExampleDP;
            type RqNTT = cyclotomic_rings::rings::BabyBearRingNTT;
            type CS = cyclotomic_rings::rings::BabyBearChallengeSet;
            "#,
        ),
        "Frog" => generated_code.push_str(
            r#"
            const N: usize = N_FROG;
            type DP = FrogExampleDP;
            type RqNTT = cyclotomic_rings::rings::FrogRingNTT;
            type CS = cyclotomic_rings::rings::FrogChallengeSet;
            "#,
        ),
        "StarkPrime" => generated_code.push_str(
            r#"
            const N: usize = N_STARK;
            type DP = StarkPrimeExampleDP;
            type RqNTT = cyclotomic_rings::rings::StarkRingNTT;
            type CS = cyclotomic_rings::rings::StarkChallengeSet;
            "#,
        ),
        _ => panic!("Unknown ring configuration"),
    };

    fs::write(&dest_path, generated_code).unwrap();

    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=latticefold/benches/config.toml");
    println!("cargo:rerun-if-env-changed=PARAM_B");
    println!("cargo:rerun-if-env-changed=PARAM_L");
    println!("cargo:rerun-if-env-changed=PARAM_B_SMALL");
    println!("cargo:rerun-if-env-changed=PARAM_K");
    println!("cargo:rerun-if-env-changed=PARAM_KAPPA");
    println!("cargo:rerun-if-env-changed=PARAM_WIT_LEN");
    println!("cargo:rerun-if-env-changed=PARAM_X_LEN");
}

fn string_to_u128<'de, D>(deserializer: D) -> Result<u128, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let s: String = String::deserialize(deserializer)?;
    s.parse::<u128>().map_err(serde::de::Error::custom)
}

#[warn(non_snake_case)]
#[derive(Debug, Deserialize)]
pub struct BenchmarkRecord {
    pub x_len: usize,
    pub kappa: usize,
    pub n: usize,
    #[serde(deserialize_with = "string_to_u128")] // Custom deserializer for `b`
    pub b: u128,
    pub l: usize,
    pub b_small: usize,
    pub k: usize,
}

#[derive(Debug, Deserialize)]
pub struct Benchmarks {
    pub goldilocks: Vec<BenchmarkRecord>,
    pub goldilocks_non_scalar: Vec<BenchmarkRecord>,
    pub goldilocks_degree_three_non_scalar: Vec<BenchmarkRecord>,
    pub starkprime: Vec<BenchmarkRecord>,
    pub starkprime_non_scalar: Vec<BenchmarkRecord>,
    pub starkprime_degree_three_non_scalar: Vec<BenchmarkRecord>,
    pub frog: Vec<BenchmarkRecord>,
    pub frog_non_scalar: Vec<BenchmarkRecord>,
    pub frog_degree_three_non_scalar: Vec<BenchmarkRecord>,
    pub babybear: Vec<BenchmarkRecord>,
    pub babybear_non_scalar: Vec<BenchmarkRecord>,
    pub babybear_degree_three_non_scalar: Vec<BenchmarkRecord>,
}

#[derive(Debug, Deserialize)]
pub struct AjtaiRecord {
    pub kappa: usize,
    pub n: usize,
}

#[derive(Debug, Deserialize)]
pub struct Ajtai {
    pub babybear: Vec<AjtaiRecord>,
    pub goldilocks: Vec<AjtaiRecord>,
    pub starkprime: Vec<AjtaiRecord>,
    pub frog: Vec<AjtaiRecord>,
}

#[derive(Debug, Deserialize)]
pub struct BenchmarkConfig {
    pub benchmarks: Benchmarks,
    pub ajtai: Ajtai,
}

#[derive(Clone, Copy)]
pub enum R1CS {
    Scalar,
    NonScalar,
    DegreeThreeNonScalar,
}

impl ToTokens for R1CS {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let token_stream = match self {
            R1CS::Scalar => quote! { R1CS::Scalar },
            R1CS::NonScalar => quote! { R1CS::NonScalar },
            R1CS::DegreeThreeNonScalar => quote! { R1CS::DegreeThreeNonScalar },
        };

        tokens.extend(token_stream);
    }
}

fn parse_benches() {
    println!("cargo:rerun-if-changed=latticefold/benches/config.toml");
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR is not set");
    let toml_content = fs::read_to_string("benches/config.toml").expect("Failed to read TOML file");
    let config: BenchmarkConfig =
        toml::from_str(&toml_content).expect("Failed to deserialize benches/config.toml");

    let linearization_file_path = Path::new(&out_dir).join("generated_linearization_benchmarks.rs");
    let mut linearization_file =
        File::create(&linearization_file_path).expect("Failed to create benchmark generated file");

    writeln!(&mut linearization_file, "use utils::{{Bencher, R1CS}};").unwrap();
    writeln!(&mut linearization_file, "use cyclotomic_rings::rings::{{BabyBearChallengeSet, BabyBearRingNTT, FrogChallengeSet, FrogRingNTT, GoldilocksChallengeSet, GoldilocksRingNTT, StarkChallengeSet, StarkRingNTT}};").unwrap();

    let decomposition_file_path = Path::new(&out_dir).join("generated_decomposition_benchmarks.rs");
    let mut decomposition_file =
        File::create(&decomposition_file_path).expect("Failed to create benchmark generated file");

    writeln!(&mut decomposition_file, "use utils::{{Bencher, R1CS}};").unwrap();
    writeln!(&mut decomposition_file, "use cyclotomic_rings::rings::{{BabyBearChallengeSet, BabyBearRingNTT, FrogChallengeSet, FrogRingNTT, GoldilocksChallengeSet, GoldilocksRingNTT, StarkChallengeSet, StarkRingNTT}};").unwrap();

    let folding_file_path = Path::new(&out_dir).join("generated_folding_benchmarks.rs");
    let mut folding_file =
        File::create(&folding_file_path).expect("Failed to create benchmark generated file");

    writeln!(&mut folding_file, "use utils::{{Bencher, R1CS}};").unwrap();
    writeln!(&mut folding_file, "use cyclotomic_rings::rings::{{BabyBearChallengeSet, BabyBearRingNTT, FrogChallengeSet, FrogRingNTT, GoldilocksChallengeSet, GoldilocksRingNTT, StarkChallengeSet, StarkRingNTT}};").unwrap();

    let e2e_file_path = Path::new(&out_dir).join("generated_e2e_benchmarks.rs");
    let mut e2e_file =
        File::create(&e2e_file_path).expect("Failed to create benchmark generated file");

    writeln!(&mut e2e_file, "use utils::{{Bencher, R1CS}};").unwrap();
    writeln!(&mut e2e_file, "use cyclotomic_rings::rings::{{BabyBearChallengeSet, BabyBearRingNTT, FrogChallengeSet, FrogRingNTT, GoldilocksChallengeSet, GoldilocksRingNTT, StarkChallengeSet, StarkRingNTT}};").unwrap();

    let mut files = (
        linearization_file,
        decomposition_file,
        folding_file,
        e2e_file,
    );

    write_group(
        &mut files,
        &config.benchmarks.goldilocks,
        "goldilocks",
        "GoldilocksRingNTT",
        "GoldilocksChallengeSet",
        R1CS::Scalar,
        "Goldilocks Scalar",
    );
    write_group(
        &mut files,
        &config.benchmarks.goldilocks_non_scalar,
        "goldilocks_non_scalar",
        "GoldilocksRingNTT",
        "GoldilocksChallengeSet",
        R1CS::NonScalar,
        "Goldilocks Non Scalar",
    );
    write_group(
        &mut files,
        &config.benchmarks.goldilocks_degree_three_non_scalar,
        "goldilocks_degree_three_non_scalar",
        "GoldilocksRingNTT",
        "GoldilocksChallengeSet",
        R1CS::DegreeThreeNonScalar,
        "Goldilocks Degree Three Non Scalar",
    );

    write_group(
        &mut files,
        &config.benchmarks.starkprime,
        "stark_prime",
        "StarkRingNTT",
        "StarkChallengeSet",
        R1CS::DegreeThreeNonScalar,
        "Stark Scalar",
    );
    write_group(
        &mut files,
        &config.benchmarks.starkprime_non_scalar,
        "stark_prime_non_scalar",
        "StarkRingNTT",
        "StarkChallengeSet",
        R1CS::DegreeThreeNonScalar,
        "Stark Non Scalar",
    );
    write_group(
        &mut files,
        &config.benchmarks.starkprime_degree_three_non_scalar,
        "stark_prime_degree_three_non_scalar",
        "StarkRingNTT",
        "StarkChallengeSet",
        R1CS::DegreeThreeNonScalar,
        "Stark Degree Three Non Scalar",
    );

    write_group(
        &mut files,
        &config.benchmarks.frog,
        "frog",
        "FrogRingNTT",
        "FrogChallengeSet",
        R1CS::DegreeThreeNonScalar,
        "Frog Scalar",
    );
    write_group(
        &mut files,
        &config.benchmarks.frog_non_scalar,
        "frog_non_scalar",
        "FrogRingNTT",
        "FrogChallengeSet",
        R1CS::DegreeThreeNonScalar,
        "Frog Non Scalar",
    );
    write_group(
        &mut files,
        &config.benchmarks.frog_degree_three_non_scalar,
        "frog_degree_three_non_scalar",
        "FrogRingNTT",
        "FrogChallengeSet",
        R1CS::DegreeThreeNonScalar,
        "Frog Degree Three Non Scalar",
    );

    write_group(
        &mut files,
        &config.benchmarks.babybear,
        "single_babybear",
        "BabyBearRingNTT",
        "BabyBearChallengeSet",
        R1CS::DegreeThreeNonScalar,
        "BabyBear Scalar",
    );
    write_group(
        &mut files,
        &config.benchmarks.babybear_non_scalar,
        "single_babybear_non_scalar",
        "BabyBearRingNTT",
        "BabyBearChallengeSet",
        R1CS::DegreeThreeNonScalar,
        "BabyBear Non Scalar",
    );
    write_group(
        &mut files,
        &config.benchmarks.babybear_degree_three_non_scalar,
        "single_babybear_degree_three_non_scalar",
        "BabyBearRingNTT",
        "BabyBearChallengeSet",
        R1CS::DegreeThreeNonScalar,
        "BabyBear Degree Three Non Scalar",
    );

    drop(files.0);
    drop(files.1);
    drop(files.2);
    drop(files.3);

    Command::new("rustfmt")
        .arg(linearization_file_path)
        .output()
        .expect("rustfmt failed");

    Command::new("rustfmt")
        .arg(decomposition_file_path)
        .output()
        .expect("rustfmt failed");

    Command::new("rustfmt")
        .arg(folding_file_path)
        .output()
        .expect("rustfmt failed");

    Command::new("rustfmt")
        .arg(e2e_file_path)
        .output()
        .expect("rustfmt failed");

    let file_path = Path::new(&out_dir).join("generated_ajtai_benchmarks.rs");
    let mut file = File::create(&file_path).expect("Failed to create benchmark generated file");

    write_ajtai_group(
        &mut file,
        &config.ajtai.goldilocks,
        "goldilocks",
        "GoldilocksRingNTT",
    );
    write_ajtai_group(
        &mut file,
        &config.ajtai.starkprime,
        "starkprime",
        "StarkRingNTT",
    );
    write_ajtai_group(&mut file, &config.ajtai.frog, "frog", "FrogRingNTT");
    write_ajtai_group(
        &mut file,
        &config.ajtai.babybear,
        "babybear",
        "BabyBearRingNTT",
    );

    drop(file);

    Command::new("rustfmt")
        .arg(file_path)
        .output()
        .expect("rustfmt failed");
}

fn write_ajtai_group(file: &mut File, benchmarks: &[AjtaiRecord], name: &str, ring: &str) {
    let generated_blocks: Vec<_> = benchmarks.iter().map(|b| {
        let (kappa, n) = (b.kappa, b.n);
        let ring = Ident::new(ring, Span::call_site());
        quote! {
            if ENV.ajtai
            {
                const KAPPA: usize = #kappa;
                const N: usize = #n;
                type R = #ring;

                group.bench_function(
                BenchmarkId::new("CommitNTT", format!("KAPPA={}, N={}", KAPPA, N)),
                |b| {
                    let mut rng = ark_std::test_rng();
                    let witness: Vec<R> = (0..N).map(|_| R::rand(&mut rng)).collect();
                    let ajtai_data: AjtaiCommitmentScheme<R> = AjtaiCommitmentScheme::rand(KAPPA, N, &mut rng);
                    b.iter(|| {
                        let _ = ajtai_data.commit_ntt(&witness);
                    })
                },
                );

                // NTT -> INTT (coefficients)
                group.bench_function(
                    BenchmarkId::new("NTT->INTT", format!("KAPPA={}, N={}", KAPPA, N)),
                    |b| {
                        let mut rng = ark_std::test_rng();
                        let witness: Vec<R> = (0..N).map(|_| R::rand(&mut rng)).collect();
                        b.iter_batched(
                            || witness.clone(),
                            |witness| {
                                let _ = ICRT::elementwise_icrt(witness);
                            },
                            SmallInput,
                        );
                    },
                );

                // INTT -> NTT
                group.bench_function(
                    BenchmarkId::new("INTT->NTT", format!("KAPPA={}, N={}", KAPPA, N)),
                    |b| {
                        let mut rng = ark_std::test_rng();
                        let witness: Vec<R> = (0..N).map(|_| R::rand(&mut rng)).collect();
                        let witness_3 = witness.clone();
                        let coeff = ICRT::elementwise_icrt(witness_3);
                        b.iter_batched(
                            || coeff.clone(),
                            |coeff| {
                                let _: Vec<R> = CRT::elementwise_crt(coeff);
                            },
                            SmallInput,
                        );
                    },
                );
            };
        }
    }).collect();

    let function_name = format!("bench_ajtai_{name}");
    let function_ident = Ident::new(&function_name, Span::call_site());
    let benchmark_name = format!("Ajtai {name}");

    write!(file, "{}", quote! {
        fn #function_ident(c: &mut Criterion) {
            let plot_config = PlotConfiguration::default().summary_scale(AxisScale::Logarithmic);
            let mut group = c.benchmark_group(#benchmark_name);
            group.plot_config(plot_config.clone());
            #(#generated_blocks)*
        }
    })
    .unwrap();
}

fn write_group(
    files: &mut (File, File, File, File),
    benchmarks: &[BenchmarkRecord],
    group: &str,
    ring: &str,
    cs: &str,
    scalar: R1CS,
    group_name: &str,
) {
    write!(
        files.0,
        "{}",
        write_function(
            benchmarks,
            group,
            "linearization",
            ring,
            cs,
            scalar,
            group_name
        )
    )
    .unwrap();
    write!(
        files.1,
        "{}",
        write_function(
            benchmarks,
            group,
            "decomposition",
            ring,
            cs,
            scalar,
            group_name
        )
    )
    .unwrap();
    write!(
        files.2,
        "{}",
        write_function(benchmarks, group, "folding", ring, cs, scalar, group_name)
    )
    .unwrap();
    write!(
        files.3,
        "{}",
        write_function(benchmarks, group, "e2e", ring, cs, scalar, group_name)
    )
    .unwrap();
}

fn write_function(
    benchmarks: &[BenchmarkRecord],
    group: &str,
    subprotocol: &str,
    ring: &str,
    cs: &str,
    scalar: R1CS,
    group_name: &str,
) -> TokenStream {
    let cs = Ident::new(cs, Span::call_site());
    let ring = Ident::new(ring, Span::call_site());
    let prover_function = Ident::new(&format!("bench_{subprotocol}_prover"), Span::call_site());
    let verifier_function = Ident::new(&format!("bench_{subprotocol}_verifier"), Span::call_site());
    let subprotocol_ident = Ident::new(subprotocol, Span::call_site());

    let generated_blocks: Vec<_> = benchmarks
        .iter()
        .map(|b| {
            let (x_len, kappa, n, b, l, b_small, k) = (b.x_len, b.kappa, b.n, b.b, b.l, b.b_small, b.k);
            quote! {
                if ENV.#subprotocol_ident && ENV.#ring
                {
                    const X_LEN: usize = #x_len;
                    const KAPPA: usize = #kappa;
                    const WIT_LEN: usize = #n;
                    const N: usize = #n * #l;

                    #[derive(Clone)]
                    struct DP {}
                    impl DecompositionParams for DP {
                        const B: u128 = #b;
                        const L: usize = #l;
                        const B_SMALL: usize = #b_small;
                        const K: usize = #k;
                    }

                    type CS = #cs;
                    type R = #ring;

                    type BlockBencher = Bencher<DP, R, CS>;

                    if X_LEN == ENV.x_len.unwrap_or(X_LEN) &&
                        KAPPA == ENV.kappa.unwrap_or(KAPPA) &&
                        N == ENV.n.unwrap_or(N) &&
                        WIT_LEN == ENV.wit_len.unwrap_or(WIT_LEN) &&
                        DP::B == ENV.b.unwrap_or(DP::B) &&
                        DP::L == ENV.l.unwrap_or(DP::L) &&
                        DP::B_SMALL == ENV.b_small.unwrap_or(DP::B_SMALL) &&
                        DP::K == ENV.k.unwrap_or(DP::K)
                    {
                        if ENV.prover {
                            BlockBencher::#prover_function(&mut group, X_LEN, N, WIT_LEN, KAPPA, #scalar);
                        };

                        if ENV.verifier {
                            BlockBencher::#verifier_function(&mut group, X_LEN, N, WIT_LEN, KAPPA, #scalar);
                        };
                    }
                };
            }
        })
        .collect();

    let function_name = format!("bench_{}_{}", group, subprotocol);
    let function_ident = Ident::new(&function_name, Span::call_site());

    quote! {
        #[allow(dead_code)]
        fn #function_ident(c: &mut Criterion) {
            let plot_config = PlotConfiguration::default().summary_scale(AxisScale::Logarithmic);
            let mut group = c.benchmark_group(#group_name);
            group.plot_config(plot_config.clone());
            #(#generated_blocks)*
        }
    }
}
